# Core Operational Rules for Agents

**This is the single source of truth for how agents should work on this project.** Reference documentation is in `/docs/reference/`.

---

## Language-Specific Coding Standards

### Language Version Enforcement (if applicable)

**BEFORE IMPLEMENTING CODE IN A LANGUAGE WITH VERSION CONSTRAINTS:**

1. **Cite applicable rules**: State the language version and feature constraints at the start of implementation
2. **Ask for explicit confirmation**: Wait for user approval before proceeding
3. **Verify compilation**: Confirm the code compiles/runs against the specified language version

### Naming Conventions

- camelCase for methods and variables
- PascalCase for classes/types
- ALL_CAPS for constants
- Member variables: prefix "m" (e.g., `mDataPersister`)
- Static/module-level fields: prefix "s" (e.g., `sInstance`)

### Formatting & Structure

- Indentation: 4 spaces (no tabs)
- Opening brace on same line as declaration
- No trailing whitespace

### Documentation

- Documentation for all public classes and methods
- Comments: `// TODO:` (blocks functionality), `// POST_MVP:` (deferred work), `// FIXME:` (known bugs), `// NOTE:` or `// IMPORTANT:` (critical context)

---

## Code Quality Essentials

### General Principles

- Write simple, verbose code over dense, terse code
- Follow DRY (Don't Repeat Yourself)
- Use meaningful names for variables, methods, and classes
- Keep methods and classes focused on single responsibility

### Testing Standards (MANDATORY)

- **100% test pass rate required**: Always run full test suite and verify before completion
- Unit tests for all public methods
- Use descriptive test names that explain what's being tested
- Follow AAA pattern: Arrange, Act, Assert

### Error Handling

- Use specific exceptions with descriptive messages
- Proper resource cleanup (try-with-resources, finally blocks, shutdown hooks)
- Handle exceptions at appropriate levels

---

## Critical Code Validation

### Code Classification

**Critical Code** (requires enhanced validation):

- Timestamp conversions and timezone handling
- Data pagination and chunking logic
- Database operations with sensitive data
- Complex calculations and business logic
- External API integration
- Authentication and authorization

**Non-Critical Code**:

- UI/display formatting
- Logging and debugging output
- Configuration file reading
- Documentation updates

### Validation Requirements for Critical Code

**Agent MUST**:

1. Restate requirements in plain language
2. Identify edge cases that could cause issues
3. Ask explicit user confirmation before proceeding
4. Add explicit comments explaining WHY approach was chosen
5. Propose test cases covering unit, integration, and manual validation
6. Provide verification scripts for data operations
7. Confirm post-implementation validation checklist completion

---

## Critical Project Constraints

### MVP Stage Guidelines

- **Breaking changes OK**: API changes, schema changes, data loss acceptable during MVP
- **Speed over perfection**: Quick solutions, manual testing, fix forward
- **Database operations**: Use simple approaches, migrations/versioning not required during MVP
- **API versioning**: Not required during MVP
- Transition out when: user base grows, data matters, compliance required, team expands

---

## Git Workflow (CRITICAL)

### âš ï¸ NEVER COMMIT WITHOUT EXPLICIT USER APPROVAL

**MANDATORY PROCESS**:

1. User explicitly requests commit action
2. Agent presents what will be committed
3. Agent asks for approval
4. User confirms
5. ONLY THEN execute git commit

**Commit Message Format**:

- Concise and descriptive: "fix: pagination order" not "fixed pagination"
- Imperative mood: "Add" not "Added"
- Under 50 characters for main message
- Include scope: "feat: add pattern validation"

### Respecting .gitignore (CRITICAL)

**BEFORE EDITING ANY FILE**:

1. **Check `.gitignore`** first - never manually edit ignored files
2. **Identify generated files**: Files in `.gitignore` are auto-generated by tools or build processes
3. **Only edit source files**: Edit the source that generates these files, not the generated output
4. **If unsure**: Ask the user before editing any file

---

## Memory Bank Structure & Guidelines

### activeContext.md - Current Work Focus (HIGH PRIORITY)

**Purpose**: Immediate context for what to work on next (1-3 day horizon)

**Required Structure:**

```markdown
## Active Context

### Current Work Focus [ðŸ”´ CRITICAL PATH]

**Primary Focus:** [1-2 sentence summary of immediate work]

- **Key Activities:** [2-3 bullet points max of current tasks]
- **Timeframe:** [current timeline/deadlines]

### Recent Changes (Last 1-2 Weeks)

- **Category:** [brief summary of recent work]

### Immediate Next Steps (Next 1-3 Days)

1. **[Priority 1]** - [specific task/assignee]
2. **[Priority 2]** - [specific task/assignee]
3. **[Priority 3]** - [specific task/assignee]

### Active Decisions & Blockers

- **[Decision/Blocker]**: [status, options, timeline]

### Current Team Priorities

- **[Team Member]**: [their immediate focus]
```

**Content Boundaries:**

- âœ… Current work focus & immediate priorities
- âœ… Recent changes (last 1-2 weeks max)
- âœ… Active decisions requiring attention
- âœ… Next 1-3 day priorities
- âŒ Historical context (belongs in progress.md)
- âŒ Reference documentation (belongs in systemPatterns.md)
- âŒ Long-term roadmap (belongs in ACTIVE_PLAN.md)

**File Maintenance:**

- Max length: 400 lines (concise for quick reading)
- Update frequency: After each major change
- File precedence: activeContext.md > progress.md > ACTIVE_PLAN.md

### progress.md - Project Status & History

**Purpose**: Cumulative project status, what works/doesn't work, historical context

**Content Focus:**

- What works (completed features)
- What's left to build (remaining tasks)
- Current status and known issues
- Historical project evolution

### systemPatterns.md - Architecture & Technical Decisions

**Purpose**: Technical architecture, patterns, and reference documentation

**Content Focus:**

- System architecture diagrams
- Technical implementation patterns
- API contracts and interfaces
- Coding standards and conventions

### Memory Bank Updates (MANDATORY)

Update these files after significant changes:

- **activeContext.md**: Current work focus, recent changes, next steps, active decisions
- **progress.md**: What works, what's left, current status, known issues
- **systemPatterns.md**: Architecture changes, technical decisions

**When to update**: New features, architecture changes, phase completions, priority shifts

---

## Documentation Standards

### File Usage Guidelines (CRITICAL - PREVENT CONTEXT BLOAT)

**CHANGELOG.md** - PRIMARY DESTINATION FOR ALL CODE CHANGES:

- **ALL** bug fixes, features, improvements, and code changes regardless of size
- Documentation updates and configuration changes
- Any change that affects what the system does or how it works

**activeContext.md** - WORK PRIORITIES AND MAJOR DECISIONS ONLY:

- Work focus/priority shifts (major changes only)
- New blocking issues discovered that affect immediate work
- Team resource allocation changes
- Timeline adjustments requiring immediate attention
- **NOT**: Individual bug fixes, minor improvements, or incremental changes

**progress.md** - FEATURE STATUS AND SYSTEM CAPABILITIES:

- Completion of major features or phases
- Current system capabilities and limitations
- Known issues affecting overall system status
- Historical project evolution and what works/doesn't work

**systemPatterns.md** - ARCHITECTURE AND TECHNICAL DECISIONS:

- Architecture changes and technical implementation patterns
- API contracts and interface changes
- Coding standards and conventions updates

### Documentation Discipline

- **Default to CHANGELOG.md** for any code change, fix, or improvement
- **Reserve activeContext.md** for decisions requiring immediate team attention
- **Keep activeContext.md concise** (< 400 lines) by avoiding detailed change histories
- **Update memory bank files sparingly** - only when context actually changes work priorities

---

## API Design Principles

### Method Design

- Verbs for actions (`download()`, `process()`), nouns for getters (`getConfiguration()`)
- `is`/`has` prefixes for booleans
- â‰¤3 parameters; use config objects for complex cases
- Meaningful return types, Optional/nullable for values that may not exist
- Immutable collections for return values

### Error Handling

- Specific exception/error types with meaningful messages
- Proper resource cleanup
- Graceful failure handling

### Serialization

- Use appropriate language serialization libraries (Jackson, Gson, JSON.stringify, etc.)
- Always test serialization output matches expected types
- Document serialization behavior in comments
- Maintain API contracts between client and server

---

## Task Execution Standards

### Code Exclusion Rules

**LEGACY CODE - DO NOT MODIFY:**

- Code marked as v0 or legacy, preserved for historical reference
- Never apply modern standards, linting fixes, or refactoring to legacy code

### Don't Reinvent the Wheel

**ALWAYS check for existing implementations before creating new code:**

- Search existing codebase with Grep and finder
- Check utility classes/modules for existing helpers
- Review imports to see what's already available
- Examine configuration for feature flags
- Verify APIs already provide needed functionality

Only create new code after confirming no existing solution exists.

### Implementation Priority

1. **Check `.gitignore` before editing any file** - never edit files in `.gitignore`
2. Implement requested functionality completely
3. Ensure the code works as intended
4. **Run complete test suite and verify 100% pass rate**
5. **Update memory bank for significant changes**
6. Address linting, formatting, and style issues
7. **Run test suite again to ensure no regressions**
8. **NEVER commit without explicit user approval** - present changes and wait for confirmation

### Task Repetition Prevention

If asked to repeat the same task more than 3 times consecutively, pause and ask: "I notice I'm being asked to repeat a similar task. Would you like me to continue, or should we review the approach?"

### Code Review (MANDATORY)

**Every completed task MUST include an AI code review before changes are committed:**

1. **Implement Changes**: Complete the task (code, tests, docs) but **DO NOT COMMIT**.
2. **Run Review**: Use appropriate code review tool (e.g., `coderabbit review --plain`) to analyze the changes.
3. **Present Findings**: Detail the updates that would result in cleaner, more maintainable code based on the analysis.
4. **Wait for Approval**: The user must explicitly approve the changes after seeing the review.
5. **Commit**: Only execute git commit after explicit user confirmation.

**Review Scope:**
- Code quality, best practices, potential bugs
- Naming conventions and style consistency
- Performance and security concerns
- Test coverage adequacy
- Documentation completeness
